use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use tempfile::TempDir;

fn envtool() -> Command {
    Command::cargo_bin("envtool").unwrap()
}

#[test]
fn test_pull_dry_run() {
    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .assert()
        .success()
        .stdout(predicate::str::contains("Variables to resolve"))
        .stdout(predicate::str::contains("VITE_ENV"))
        .stdout(predicate::str::contains("static"))
        .stdout(predicate::str::contains("would be written"));
}

#[test]
fn test_pull_writes_env_file() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--non-interactive")
        .arg("-o")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("Wrote"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=staging"));
    assert!(content.contains("VITE_BASE_URL=http://localhost:5173"));
    assert!(content.contains("VITE_PROJECT_ID=my-app-staging"));
    assert!(content.contains("VITE_OPTIONAL_FLAG=true"));
    // VITE_API_KEY should be resolved via echo command
    assert!(content.contains("VITE_API_KEY=API_KEY-local"));
    // Should have the header comment
    assert!(content.contains("Generated by envtool"));
    assert!(content.contains("Environment: local"));
}

#[test]
fn test_pull_refuses_overwrite_without_force() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--non-interactive")
        .arg("-o")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stderr(predicate::str::contains("already exists"));
}

#[test]
fn test_pull_force_overwrites() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--non-interactive")
        .arg("--force")
        .arg("-o")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("Wrote"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=staging"));
}

#[test]
fn test_pull_invalid_environment() {
    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("nonexistent")
        .arg("--dry-run")
        .assert()
        .failure()
        .stderr(predicate::str::contains("not found"));
}

#[test]
fn test_pull_production_env() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env.production");

    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("production")
        .arg("--non-interactive")
        .arg("-o")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success();

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=production"));
    assert!(content.contains("VITE_BASE_URL=https://app.example.com"));
    assert!(content.contains("VITE_PROJECT_ID=my-app"));
    assert!(content.contains("VITE_API_KEY=API_KEY-production"));
}

#[test]
fn test_pull_backend_with_echo_source() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env.local");

    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/valid_backend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--non-interactive")
        .arg("-o")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success();

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("GOOGLE_CLIENT_ID=secret-value-for-GOOGLE_CLIENT_ID"));
    assert!(content.contains("GOOGLE_CLIENT_SECRET=secret-value-for-GOOGLE_CLIENT_SECRET"));
    assert!(content.contains("STRIPE_SECRET_KEY=secret-value-for-STRIPE_SECRET_KEY"));
    assert!(content.contains("TOKEN_ENCRYPTION_KEY=secret-value-for-TOKEN_ENCRYPTION_KEY"));
    // OPTIONAL_KEY should not be present for local env (only staging+production)
    assert!(!content.contains("OPTIONAL_KEY"));
}

#[test]
fn test_pull_non_interactive_skips_manual() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envtool()
        .arg("pull")
        .arg("-s")
        .arg("tests/fixtures/manual_schema.yaml")
        .arg("-e")
        .arg("local")
        .arg("--non-interactive")
        .arg("-o")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("skipped"));

    let content = fs::read_to_string(&output_path).unwrap();
    // Static var should be present
    assert!(content.contains("STATIC_VAR=static-value"));
    // Manual var should be skipped
    assert!(!content.contains("MANUAL_VAR"));
}
