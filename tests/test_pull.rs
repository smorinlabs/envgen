use assert_cmd::cargo::cargo_bin_cmd;
use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use tempfile::TempDir;

fn envgen() -> Command {
    cargo_bin_cmd!("envgen")
}

#[test]
fn test_pull_dry_run() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .assert()
        .success()
        .stdout(predicate::str::contains("Variables to resolve"))
        .stdout(predicate::str::contains("VITE_ENV"))
        .stdout(predicate::str::contains("static"))
        .stdout(predicate::str::contains("would be written"));
}

#[test]
fn test_pull_dry_run_does_not_count_non_interactive_manual() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/manual_only_schema.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            "No variables would be resolved. Output file would not be written.",
        ));
}

#[test]
fn test_pull_dry_run_schema_validation_error_exits_1() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/broken_static_template.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("Schema errors"))
        .stderr(predicate::str::contains("Schema validation failed"));
}

#[test]
fn test_pull_dry_run_expands_manual_instructions() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/manual_schema.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            "https://example.com/project/test-project",
        ))
        .stdout(predicate::str::contains("{project}").not());
}

#[test]
fn test_pull_writes_env_file() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("Wrote"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=staging"));
    assert!(content.contains("VITE_BASE_URL=http://localhost:5173"));
    assert!(content.contains("VITE_PROJECT_ID=my-app-staging"));
    assert!(content.contains("VITE_STATIC_KEY_TEST=MY_SOURCE_KEY"));
    assert!(content.contains("VITE_OPTIONAL_FLAG=true"));
    // VITE_API_KEY should be resolved via echo command
    assert!(content.contains("VITE_API_KEY=API_KEY-local"));
    // Should have the header comment
    assert!(content.contains("Generated by envgen"));
    assert!(content.contains("Environment: local"));
}

#[test]
fn test_pull_refuses_overwrite_without_force() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stderr(predicate::str::contains("already exists"));
}

#[test]
fn test_pull_dry_run_refuses_overwrite_without_force() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stderr(predicate::str::contains("already exists"));
}

#[test]
fn test_pull_force_overwrites() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--force")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("Wrote"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=staging"));
}

#[test]
fn test_pull_invalid_environment() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("nonexistent")
        .arg("--dry-run")
        .assert()
        .failure()
        .stderr(predicate::str::contains("not found"));
}

#[test]
fn test_pull_production_env() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env.production");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("production")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success();

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=production"));
    assert!(content.contains("VITE_BASE_URL=https://app.example.com"));
    assert!(content.contains("VITE_PROJECT_ID=my-app"));
    assert!(content.contains("VITE_API_KEY=API_KEY-production"));
}

#[test]
fn test_pull_backend_with_echo_source() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env.local");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_backend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success();

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("GOOGLE_CLIENT_ID=secret-value-for-GOOGLE_CLIENT_ID"));
    assert!(content.contains("GOOGLE_CLIENT_SECRET=secret-value-for-GOOGLE_CLIENT_SECRET"));
    assert!(content.contains("STRIPE_SECRET_KEY=secret-value-for-STRIPE_SECRET_KEY"));
    assert!(content.contains("TOKEN_ENCRYPTION_KEY=secret-value-for-TOKEN_ENCRYPTION_KEY"));
    // OPTIONAL_KEY should not be present for local env (only staging+production)
    assert!(!content.contains("OPTIONAL_KEY"));
}

#[test]
fn test_pull_default_skips_manual() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/manual_schema.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("skipped"));

    let content = fs::read_to_string(&output_path).unwrap();
    // Static var should be present
    assert!(content.contains("STATIC_VAR=static-value"));
    // Manual var should be skipped
    assert!(!content.contains("MANUAL_VAR"));
}

#[test]
fn test_pull_invalid_schema_fails_before_execution() {
    let tmp = TempDir::new().unwrap();
    let side_effect_path = tmp.path().join("side_effect.txt");
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/invalid_schema_with_side_effect.yaml")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .env("SIDE_EFFECT", side_effect_path.to_str().unwrap())
        .assert()
        .failure()
        .stderr(predicate::str::contains("Schema validation failed"));

    assert!(
        !side_effect_path.exists(),
        "side effect command should not run"
    );
    assert!(!output_path.exists(), "output file should not be written");
}

#[test]
fn test_pull_missing_destination_for_environment() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/missing_destination.yaml")
        .arg("-e")
        .arg("staging")
        .assert()
        .failure()
        .stderr(predicate::str::contains(
            "No destination defined for environment",
        ));
}

#[test]
fn test_pull_required_command_failure_exits_1() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/required_failing_command.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("Exit code: 1"));

    assert!(!output_path.exists(), "output file should not be written");
}

#[test]
fn test_pull_mixed_optional_command_failure_exits_1_and_does_not_write() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/mixed_optional_command_failure.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("warning"))
        .stdout(predicate::str::contains("FAIL_OPTIONAL"))
        .stdout(predicate::str::contains("Exit code: 1"))
        .stdout(predicate::str::contains(
            "No file written due to write-blocking resolution failures.",
        ));

    assert!(!output_path.exists(), "output file should not be written");
}

#[test]
fn test_pull_mixed_required_command_failure_exits_1_and_does_not_write() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/mixed_required_command_failure.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("warning"))
        .stdout(predicate::str::contains("FAIL_REQUIRED"))
        .stdout(predicate::str::contains("Exit code: 1"))
        .stdout(predicate::str::contains(
            "No file written due to write-blocking resolution failures.",
        ));

    assert!(!output_path.exists(), "output file should not be written");
}

#[test]
fn test_pull_mixed_optional_command_failure_write_on_error_writes_partial_and_exits_1() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/mixed_optional_command_failure.yaml")
        .arg("-e")
        .arg("local")
        .arg("--write-on-error")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("Wrote 1 variable to"))
        .stdout(predicate::str::contains("Exit code: 1"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("OK_STATIC=ok"));
    assert!(!content.contains("FAIL_OPTIONAL="));
}

#[test]
fn test_pull_mixed_required_command_failure_write_on_error_writes_partial_and_exits_1() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/mixed_required_command_failure.yaml")
        .arg("-e")
        .arg("local")
        .arg("--write-on-error")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("Wrote 1 variable to"))
        .stdout(predicate::str::contains("Exit code: 1"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("OK_STATIC=ok"));
    assert!(!content.contains("FAIL_REQUIRED="));
}

#[test]
fn test_pull_force_keeps_existing_file_when_write_blocked() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "KEEP=1\n").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/mixed_optional_command_failure.yaml")
        .arg("-e")
        .arg("local")
        .arg("--force")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains(
            "No file written due to write-blocking resolution failures.",
        ));

    let content = fs::read_to_string(&output_path).unwrap();
    assert_eq!(content, "KEEP=1\n");
}

#[test]
fn test_pull_force_with_write_on_error_overwrites_existing_file() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "KEEP=1\n").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/mixed_optional_command_failure.yaml")
        .arg("-e")
        .arg("local")
        .arg("--force")
        .arg("--write-on-error")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("Wrote 1 variable to"))
        .stdout(predicate::str::contains("Exit code: 1"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("OK_STATIC=ok"));
    assert!(!content.contains("KEEP=1"));
}

#[test]
fn test_pull_no_vars_resolved_does_not_write_file() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/manual_only_schema.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains(
            "No variables resolved. Output file not written.",
        ));

    assert!(!output_path.exists(), "output file should not be written");
}

#[test]
fn test_pull_source_timeout_terminates_command() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    let side_effect_path = tmp.path().join("side_effect.txt");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/timeout_side_effect.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .arg("--source-timeout")
        .arg("1")
        .env("SIDE_EFFECT", side_effect_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("timed out"));

    std::thread::sleep(std::time::Duration::from_secs(3));
    assert!(
        !side_effect_path.exists(),
        "timed-out command should not perform side effects after envgen exits"
    );
}
