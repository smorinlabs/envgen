use assert_cmd::cargo::cargo_bin_cmd;
use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use tempfile::TempDir;

fn envgen() -> Command {
    cargo_bin_cmd!("envgen")
}

#[test]
fn test_pull_dry_run() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .assert()
        .success()
        .stdout(predicate::str::contains("Variables to resolve"))
        .stdout(predicate::str::contains("VITE_ENV"))
        .stdout(predicate::str::contains("static"))
        .stdout(predicate::str::contains("would be written"));
}

#[test]
fn test_pull_writes_env_file() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("Wrote"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=staging"));
    assert!(content.contains("VITE_BASE_URL=http://localhost:5173"));
    assert!(content.contains("VITE_PROJECT_ID=my-app-staging"));
    assert!(content.contains("VITE_OPTIONAL_FLAG=true"));
    // VITE_API_KEY should be resolved via echo command
    assert!(content.contains("VITE_API_KEY=API_KEY-local"));
    // Should have the header comment
    assert!(content.contains("Generated by envgen"));
    assert!(content.contains("Environment: local"));
}

#[test]
fn test_pull_refuses_overwrite_without_force() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stderr(predicate::str::contains("already exists"));
}

#[test]
fn test_pull_dry_run_refuses_overwrite_without_force() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--dry-run")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stderr(predicate::str::contains("already exists"));
}

#[test]
fn test_pull_force_overwrites() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");
    fs::write(&output_path, "existing content").unwrap();

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--force")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("Wrote"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=staging"));
}

#[test]
fn test_pull_invalid_environment() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("nonexistent")
        .arg("--dry-run")
        .assert()
        .failure()
        .stderr(predicate::str::contains("not found"));
}

#[test]
fn test_pull_production_env() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env.production");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_frontend.yaml")
        .arg("-e")
        .arg("production")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success();

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("VITE_ENV=production"));
    assert!(content.contains("VITE_BASE_URL=https://app.example.com"));
    assert!(content.contains("VITE_PROJECT_ID=my-app"));
    assert!(content.contains("VITE_API_KEY=API_KEY-production"));
}

#[test]
fn test_pull_backend_with_echo_source() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env.local");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/valid_backend.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success();

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("GOOGLE_CLIENT_ID=secret-value-for-GOOGLE_CLIENT_ID"));
    assert!(content.contains("GOOGLE_CLIENT_SECRET=secret-value-for-GOOGLE_CLIENT_SECRET"));
    assert!(content.contains("STRIPE_SECRET_KEY=secret-value-for-STRIPE_SECRET_KEY"));
    assert!(content.contains("TOKEN_ENCRYPTION_KEY=secret-value-for-TOKEN_ENCRYPTION_KEY"));
    // OPTIONAL_KEY should not be present for local env (only staging+production)
    assert!(!content.contains("OPTIONAL_KEY"));
}

#[test]
fn test_pull_default_skips_manual() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/manual_schema.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("skipped"));

    let content = fs::read_to_string(&output_path).unwrap();
    // Static var should be present
    assert!(content.contains("STATIC_VAR=static-value"));
    // Manual var should be skipped
    assert!(!content.contains("MANUAL_VAR"));
}

#[test]
fn test_pull_invalid_schema_fails_before_execution() {
    let tmp = TempDir::new().unwrap();
    let side_effect_path = tmp.path().join("side_effect.txt");
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/invalid_schema_with_side_effect.yaml")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .env("SIDE_EFFECT", side_effect_path.to_str().unwrap())
        .assert()
        .failure()
        .stderr(predicate::str::contains("Schema validation failed"));

    assert!(
        !side_effect_path.exists(),
        "side effect command should not run"
    );
    assert!(!output_path.exists(), "output file should not be written");
}

#[test]
fn test_pull_missing_destination_for_environment() {
    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/missing_destination.yaml")
        .arg("-e")
        .arg("staging")
        .assert()
        .failure()
        .stderr(predicate::str::contains(
            "No destination defined for environment",
        ));
}

#[test]
fn test_pull_required_command_failure_exits_1() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/required_failing_command.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .failure()
        .stdout(predicate::str::contains("Exit code: 1"));

    assert!(!output_path.exists(), "output file should not be written");
}

#[test]
fn test_pull_optional_command_failure_exits_0_with_warning() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/optional_failing_command.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("warning"))
        .stdout(predicate::str::contains("FAIL_OPTIONAL"));

    let content = fs::read_to_string(&output_path).unwrap();
    assert!(content.contains("OK_STATIC=ok"));
    assert!(!content.contains("FAIL_OPTIONAL="));
}

#[test]
fn test_pull_no_vars_resolved_does_not_write_file() {
    let tmp = TempDir::new().unwrap();
    let output_path = tmp.path().join(".env");

    envgen()
        .arg("pull")
        .arg("-c")
        .arg("tests/fixtures/manual_only_schema.yaml")
        .arg("-e")
        .arg("local")
        .arg("--destination")
        .arg(output_path.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains(
            "No variables resolved. Output file not written.",
        ));

    assert!(!output_path.exists(), "output file should not be written");
}
