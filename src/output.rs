use anyhow::Result;
use chrono::Utc;
use comfy_table::{ContentArrangement, Table};
use std::path::Path;

use crate::schema::types::Schema;

fn format_source_summary(schema: &Schema, var: &crate::schema::types::Variable) -> String {
    let var_envs: Vec<String> = match &var.environments {
        Some(envs) => envs.clone(),
        None => schema.environment_names(),
    };

    let mut by_source: std::collections::BTreeMap<String, Vec<String>> =
        std::collections::BTreeMap::new();
    for env in var_envs {
        let source = var.effective_source_for_env(&env).unwrap_or("<missing>");
        by_source
            .entry(source.to_string())
            .or_default()
            .push(env.to_string());
    }

    if by_source.len() == 1 {
        return by_source.keys().next().unwrap().to_string();
    }

    by_source
        .into_iter()
        .map(|(source, envs)| format!("{}({})", source, envs.join(", ")))
        .collect::<Vec<String>>()
        .join("; ")
}

/// Write the .env file with a header comment and key=value pairs.
pub fn write_env_file(
    path: &Path,
    schema_path: &str,
    env_name: &str,
    variables: &[(String, String)],
) -> Result<()> {
    let now = Utc::now().format("%Y-%m-%dT%H:%M:%SZ");

    let mut content = String::new();
    content.push_str(&format!("# Generated by envtool v{}\n", env!("CARGO_PKG_VERSION")));
    content.push_str(&format!("# Schema: {}\n", schema_path));
    content.push_str(&format!("# Environment: {}\n", env_name));
    content.push_str(&format!("# Generated at: {}\n", now));
    content.push_str("#\n");
    content.push_str("# DO NOT EDIT â€” regenerate with:\n");
    content.push_str(&format!(
        "#   envtool pull -s {} -e {} --force\n",
        schema_path, env_name
    ));
    content.push('\n');

    for (key, value) in variables {
        // Quote the value if it contains spaces, #, or special characters
        if needs_quoting(value) {
            content.push_str(&format!("{}=\"{}\"\n", key, escape_value(value)));
        } else {
            content.push_str(&format!("{}={}\n", key, value));
        }
    }

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    std::fs::write(path, content)?;
    Ok(())
}

fn needs_quoting(value: &str) -> bool {
    value.contains(' ')
        || value.contains('#')
        || value.contains('"')
        || value.contains('\'')
        || value.contains('\n')
        || value.contains('\t')
        || value.is_empty()
}

fn escape_value(value: &str) -> String {
    value
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
}

/// Format a table of variables for the `list` command.
pub fn format_variable_table(
    schema: &Schema,
    env_filter: Option<&str>,
) -> String {
    let mut table = Table::new();
    table.set_content_arrangement(ContentArrangement::Dynamic);
    table.set_header(vec!["Name", "Environments", "Source"]);

    let mut count = 0;

    for (var_name, var) in &schema.variables {
        let var_envs: Vec<String> = match &var.environments {
            Some(envs) => envs.clone(),
            None => schema.environment_names(),
        };

        // If filtering by environment, skip variables that don't apply
        if let Some(filter) = env_filter {
            if !var_envs.iter().any(|e| e == filter) {
                continue;
            }
        }

        let envs_display = var_envs.join(", ");
        let source_summary = format_source_summary(schema, var);
        table.add_row(vec![var_name.as_str(), &envs_display, &source_summary]);
        count += 1;
    }

    let env_count = schema.environments.len();

    let footer = format!(
        "\n{} variable{} across {} environment{}",
        count,
        if count == 1 { "" } else { "s" },
        env_count,
        if env_count == 1 { "" } else { "s" },
    );

    format!("{}\n{}", table, footer)
}

/// Format variables as JSON for the `list --format json` command.
pub fn format_variable_json(
    schema: &Schema,
    env_filter: Option<&str>,
) -> Result<String> {
    let mut result: Vec<serde_json::Value> = Vec::new();

    for (var_name, var) in &schema.variables {
        let var_envs: Vec<String> = match &var.environments {
            Some(envs) => envs.clone(),
            None => schema.environment_names(),
        };

        if let Some(filter) = env_filter {
            if !var_envs.iter().any(|e| e == filter) {
                continue;
            }
        }

        let mut obj = serde_json::Map::new();
        obj.insert("name".to_string(), serde_json::Value::String(var_name.clone()));
        obj.insert(
            "description".to_string(),
            serde_json::Value::String(var.description.clone()),
        );
        obj.insert(
            "source".to_string(),
            serde_json::Value::String(format_source_summary(schema, var)),
        );
        obj.insert(
            "sensitive".to_string(),
            serde_json::Value::Bool(var.sensitive),
        );
        obj.insert(
            "required".to_string(),
            serde_json::Value::Bool(var.required),
        );
        obj.insert(
            "environments".to_string(),
            serde_json::Value::Array(var_envs.into_iter().map(serde_json::Value::String).collect()),
        );

        if let Some(notes) = &var.notes {
            obj.insert("notes".to_string(), serde_json::Value::String(notes.clone()));
        }

        result.push(serde_json::Value::Object(obj));
    }

    Ok(serde_json::to_string_pretty(&result)?)
}

/// Mask a sensitive value for display.
pub fn mask_value(value: &str, unmask: bool) -> String {
    if unmask || value.len() <= 4 {
        value.to_string()
    } else {
        format!("{}...", &value[..4])
    }
}
